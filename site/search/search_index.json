{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"FeedbackAI Tool Documentation","text":"<p>Welcome to the official documentation of the FeedbackAI Tool.</p>"},{"location":"#description","title":"Description","text":"<p>The FeedbackAI Tool is a learning tool that allows students to submit assignments and receive feedback on their submissions. The tool uses OpenAI's API to provide AI-powered feedback on the submissions of students. The tool is designed to help students improve their understanding of various subjects by providing them with detailed feedback on their work. Furthermore the tool allows teachers to create course specific assignments for students and generate template solutions for assignments for comparison to submissions.</p>"},{"location":"#why-use-the-feedbackai-tool","title":"Why use the FeedbackAI Tool?","text":"<ul> <li>Improve Learning: The FeedbackAI Tool helps students improve their understanding of various subjects by providing them with detailed feedback on their work.</li> <li>Save Time: The tool automates the feedback process, saving teachers time and allowing them to focus on other tasks.</li> <li>Increase Engagement: The tool encourages students to engage with the material and submit assignments for feedback.</li> <li>Enhance Teaching: The tool provides teachers with valuable insights into student performance and helps them identify areas for improvement.</li> </ul>"},{"location":"#purpose","title":"Purpose","text":"<p>The purpose of this documentation is to provide detailed information on how to use the FeedbackAI Tool. The documentation includes installation instructions, API references, and more.</p>"},{"location":"assignment/","title":"Assignment","text":""},{"location":"assignment/#assignment-api-references","title":"Assignment API References","text":"<p>Create a new assignment.</p> <p>Parameters:</p> Name Type Description Default <code>assignment</code> <code>CreateAssignment</code> <p>The assignment data to be created.</p> required <code>db</code> <code>AsyncSession</code> <p>The database session. Defaults to Depends(get_async_db).</p> <code>Depends(get_async_db)</code> <p>Returns:</p> Type Description <p>The newly created assignment.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If there is an error creating the assignment.</p> Source code in <code>app/main.py</code> <pre><code>@app.post(\"/assignment/add\")\nasync def create_assignment(assignment: CreateAssignment, db: AsyncSession = Depends(get_async_db)):\n    \"\"\"\n    Create a new assignment.\n\n    Args:\n        assignment (CreateAssignment): The assignment data to be created.\n        db (AsyncSession, optional): The database session. Defaults to Depends(get_async_db).\n\n    Returns:\n        The newly created assignment.\n\n    Raises:\n        HTTPException: If there is an error creating the assignment.\n    \"\"\"\n    try: \n        repo = AssignmentRepository(session=db)\n        new_assignment = await repo.create_assignment(assignment)\n        return new_assignment\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n</code></pre> <p>Retrieve all assignments from the database.</p> <p>Parameters: - db: AsyncSession - The async database session.</p> <p>Returns: - List[Assignment]: A list of assignments retrieved from the database.</p> <p>Raises: - HTTPException: If there is an error retrieving the assignments from the database.</p> Source code in <code>app/main.py</code> <pre><code>@app.get(\"/assignments\")\nasync def get_assignments(db: AsyncSession = Depends(get_async_db)):\n    \"\"\"\n    Retrieve all assignments from the database.\n\n    Parameters:\n    - db: AsyncSession - The async database session.\n\n    Returns:\n    - List[Assignment]: A list of assignments retrieved from the database.\n\n    Raises:\n    - HTTPException: If there is an error retrieving the assignments from the database.\n    \"\"\"\n    try:\n        repo = AssignmentRepository(session=db) \n        assignments = await repo.get_assignments()\n        return assignments\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n</code></pre> <p>Retrieve an assignment by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>assignment_id</code> <code>int</code> <p>The ID of the assignment to retrieve.</p> required <code>db</code> <code>AsyncSession</code> <p>The database session. Defaults to Depends(get_async_db).</p> <code>Depends(get_async_db)</code> <p>Returns:</p> Name Type Description <code>Assignment</code> <p>The retrieved assignment.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If the assignment is not found or an error occurs during retrieval.</p> Source code in <code>app/main.py</code> <pre><code>@app.get(\"/assignment/{assignment_id}\")\nasync def get_assignment_by_id(assignment_id: int, db: AsyncSession = Depends(get_async_db)):\n    \"\"\"\n    Retrieve an assignment by its ID.\n\n    Args:\n        assignment_id (int): The ID of the assignment to retrieve.\n        db (AsyncSession, optional): The database session. Defaults to Depends(get_async_db).\n\n    Returns:\n        Assignment: The retrieved assignment.\n\n    Raises:\n        HTTPException: If the assignment is not found or an error occurs during retrieval.\n    \"\"\"\n    try:\n        repo = AssignmentRepository(session=db)\n        assignment = await repo.get_assignment_by_id(assignment_id)\n        if assignment:\n            return assignment\n        else:\n            raise HTTPException(status_code=404, detail=\"Assignment not found\")\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n</code></pre> <p>Retrieve assignments by course ID.</p> <p>Parameters:</p> Name Type Description Default <code>course_id</code> <code>int</code> <p>The ID of the course.</p> required <p>Returns:</p> Type Description <p>List[Assignment]: A list of assignments associated with the given course ID.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If there is an error retrieving the assignments.</p> Source code in <code>app/main.py</code> <pre><code>@app.get(\"/assignment/course/{course_id}\")\nasync def get_assignments_by_course_id(course_id: int, db: AsyncSession = Depends(get_async_db)):\n    \"\"\"\n    Retrieve assignments by course ID.\n\n    Args:\n        course_id (int): The ID of the course.\n\n    Returns:\n        List[Assignment]: A list of assignments associated with the given course ID.\n\n    Raises:\n        HTTPException: If there is an error retrieving the assignments.\n    \"\"\"\n    try:\n        repo = AssignmentRepository(session=db)\n        assignments = await repo.get_assignments_by_course_id(course_id)\n        return assignments\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n</code></pre> <p>Generate a template solution for a given assignment ID.</p> <p>Parameters: - assignment_id (int): The ID of the assignment for which to generate the template solution. - db (AsyncSession): The asynchronous database session.</p> <p>Returns: - template (str): The generated template solution.</p> <p>Raises: - HTTPException: If an error occurs during the generation of the template solution.</p> Source code in <code>app/main.py</code> <pre><code>@app.get(\"/template/generate/{assignment_id}\")\nasync def generate_template_solution(assignment_id: int, db: AsyncSession = Depends(get_async_db)):\n    \"\"\"\n    Generate a template solution for a given assignment ID.\n\n    Parameters:\n    - assignment_id (int): The ID of the assignment for which to generate the template solution.\n    - db (AsyncSession): The asynchronous database session.\n\n    Returns:\n    - template (str): The generated template solution.\n\n    Raises:\n    - HTTPException: If an error occurs during the generation of the template solution.\n    \"\"\"\n    try:\n        template_service = TemplateService(session=db)\n        template = await template_service.generate_template_solution(assignment_id=assignment_id)\n        return template\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n</code></pre> <p>Retrieve all templates from the database.</p> <p>Parameters: - db: AsyncSession - The async database session.</p> <p>Returns: - List[Template] - A list of templates retrieved from the database.</p> <p>Raises: - HTTPException: If there is an error retrieving the templates.</p> Source code in <code>app/main.py</code> <pre><code>@app.get(\"/templates\")\nasync def get_all_templates(db: AsyncSession = Depends(get_async_db)):\n    \"\"\"\n    Retrieve all templates from the database.\n\n    Parameters:\n    - db: AsyncSession - The async database session.\n\n    Returns:\n    - List[Template] - A list of templates retrieved from the database.\n\n    Raises:\n    - HTTPException: If there is an error retrieving the templates.\n    \"\"\"\n    try:\n        repo = TemplateRepository(session=db)\n        templates = await repo.get_all_templates()\n        return templates\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n</code></pre> <p>Add a new template solution to the database.</p> <p>Parameters:</p> Name Type Description Default <code>template_content</code> <code>CreateTemplate</code> <p>The content of the template to be created.</p> required <code>db</code> <code>AsyncSession</code> <p>The database session. Defaults to Depends(get_async_db).</p> <code>Depends(get_async_db)</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary with a success message if the template is created successfully.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If an error occurs during the template creation process.</p> Source code in <code>app/main.py</code> <pre><code>@app.post(\"/template/add\")\nasync def add_template_solution(template_content: CreateTemplate, db: AsyncSession = Depends(get_async_db)):\n    \"\"\"\n    Add a new template solution to the database.\n\n    Args:\n        template_content (CreateTemplate): The content of the template to be created.\n        db (AsyncSession, optional): The database session. Defaults to Depends(get_async_db).\n\n    Returns:\n        dict: A dictionary with a success message if the template is created successfully.\n\n    Raises:\n        HTTPException: If an error occurs during the template creation process.\n    \"\"\"\n    try:\n        repo = TemplateRepository(session=db)\n        new_template = await repo.create_template(template_content=template_content)\n        return {\"message\": \"Template created successfully\"}\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n</code></pre> <p>Retrieve templates for a specific assignment.</p> <p>Parameters:</p> Name Type Description Default <code>assignment_id</code> <code>int</code> <p>The ID of the assignment.</p> required <code>db</code> <code>AsyncSession</code> <p>The async database session. Defaults to Depends(get_async_db).</p> <code>Depends(get_async_db)</code> <p>Returns:</p> Type Description <p>List[Template]: A list of templates for the assignment.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If there is an error retrieving the templates.</p> Source code in <code>app/main.py</code> <pre><code>@app.get(\"/assignment/{assignment_id}/get_templates\")\nasync def get_templates_for_assignment(assignment_id: int, db: AsyncSession = Depends(get_async_db)):\n    \"\"\"\n    Retrieve templates for a specific assignment.\n\n    Args:\n        assignment_id (int): The ID of the assignment.\n        db (AsyncSession, optional): The async database session. Defaults to Depends(get_async_db).\n\n    Returns:\n        List[Template]: A list of templates for the assignment.\n\n    Raises:\n        HTTPException: If there is an error retrieving the templates.\n    \"\"\"\n    try:\n        repo = TemplateRepository(session=db)\n        temples_for_assignment = await repo.get_templates_for_assignment(assignment_id)\n        return temples_for_assignment\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n</code></pre>"},{"location":"installation/","title":"Installation","text":"<p>To install and run the FeedbackAI Tool Backend, follow these steps:</p>"},{"location":"installation/#clone-the-repository","title":"Clone the Repository","text":"<pre><code>git clone https://github.com/AlecVangilbergen/FeedbackAI-Tool-Backend.git\n</code></pre>"},{"location":"installation/#create-a-local-database","title":"Create a Local Database","text":"<p>Make sure you have PostgreSQL installed. Then, create a local database named <code>feedbacktool</code>.</p> <pre><code>createdb feedbacktool\n</code></pre>"},{"location":"installation/#install-dependencies","title":"Install Dependencies","text":"<p>Navigate to the project directory and install the required dependencies using <code>pip</code> and the <code>requirements.txt</code> file.</p> <pre><code>pip install -r requirements.txt\n</code></pre>"},{"location":"installation/#run-the-application","title":"Run the Application","text":"<p>You can run the application using <code>uvicorn</code>.</p> <pre><code>uvicorn app.main:app --reload\n</code></pre> <p>This command will start the FastAPI server, and you'll be able to access the API at <code>http://localhost:8000</code>.</p> <pre><code>INFO:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)\n</code></pre> <p>Open your web browser and navigate to <code>http://alecvangilbergen.github.io/FeedbackAI-Tool-Backend</code> to view the API documentation.</p>"},{"location":"organisation/","title":"Organisation","text":""},{"location":"organisation/#organisation-api-references","title":"Organisation API References","text":"<p>Create a new organisation.</p> <p>Parameters:</p> Name Type Description Default <code>organisation</code> <code>CreateOrganisation</code> <p>The details of the organisation to be created.</p> required <code>db</code> <code>AsyncSession</code> <p>The database session. Defaults to Depends(get_async_db).</p> <code>Depends(get_async_db)</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing a success message if the organisation is created successfully.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If there is an error creating the organisation.</p> Source code in <code>app/main.py</code> <pre><code>@app.post(\"/organisation/add\")\nasync def create_organisation(organisation: CreateOrganisation, db: AsyncSession = Depends(get_async_db)):\n    \"\"\"\n    Create a new organisation.\n\n    Args:\n        organisation (CreateOrganisation): The details of the organisation to be created.\n        db (AsyncSession, optional): The database session. Defaults to Depends(get_async_db).\n\n    Returns:\n        dict: A dictionary containing a success message if the organisation is created successfully.\n\n    Raises:\n        HTTPException: If there is an error creating the organisation.\n    \"\"\"\n    try:\n        repo = OrganisationRepository(session=db)  # Pass the session directly to the OrganisationRepository\n        new_organisation = await repo.create_organisation(organisation)  # Create the new organisation\n        return {\"message\": \"Organisation created successfully\"}\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n</code></pre> <p>Retrieve a list of organisations from the database.</p> <p>Parameters: - db: AsyncSession - The async database session.</p> <p>Returns: - List[Organisation] - A list of organisations retrieved from the database.</p> <p>Raises: - HTTPException: If there is an error retrieving the organisations from the database.</p> Source code in <code>app/main.py</code> <pre><code>@app.get(\"/organisations\")\nasync def get_organisations(db: AsyncSession = Depends(get_async_db)):\n    \"\"\"\n    Retrieve a list of organisations from the database.\n\n    Parameters:\n    - db: AsyncSession - The async database session.\n\n    Returns:\n    - List[Organisation] - A list of organisations retrieved from the database.\n\n    Raises:\n    - HTTPException: If there is an error retrieving the organisations from the database.\n    \"\"\"\n    try:\n        repo = OrganisationRepository(session=db)\n        organisations = await repo.get_organisations()\n        return organisations\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n</code></pre> <p>Retrieve an organisation by its ID.</p> <p>Parameters: - id (int): The ID of the organisation to retrieve. - db (AsyncSession): The asynchronous database session.</p> <p>Returns: - dict: The organisation information if found.</p> <p>Raises: - HTTPException: If the organisation is not found (status_code=404) or if there is a server error (status_code=500).</p> Source code in <code>app/main.py</code> <pre><code>@app.get(\"/organisation/id/{id}\")\nasync def get_organisation_by_id(id: int, db: AsyncSession = Depends(get_async_db)):\n    \"\"\"\n    Retrieve an organisation by its ID.\n\n    Parameters:\n    - id (int): The ID of the organisation to retrieve.\n    - db (AsyncSession): The asynchronous database session.\n\n    Returns:\n    - dict: The organisation information if found.\n\n    Raises:\n    - HTTPException: If the organisation is not found (status_code=404) or if there is a server error (status_code=500).\n    \"\"\"\n    try:\n        repo = OrganisationRepository(session=db)\n        organisation = await repo.get_organisation_by_id(id)\n        if organisation:\n            return organisation\n        else:\n            raise HTTPException(status_code=404, detail=\"Organisation not found\")\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n</code></pre> <p>Retrieve an organisation by its name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the organisation.</p> required <code>db</code> <code>AsyncSession</code> <p>The database session. Defaults to Depends(get_async_db).</p> <code>Depends(get_async_db)</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>The organisation details if found.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If the organisation is not found or an error occurs.</p> Source code in <code>app/main.py</code> <pre><code>@app.get(\"/organisation/{name}\")\nasync def get_organisation_by_name(name: str, db: AsyncSession = Depends(get_async_db)):\n    \"\"\"\n    Retrieve an organisation by its name.\n\n    Args:\n        name (str): The name of the organisation.\n        db (AsyncSession, optional): The database session. Defaults to Depends(get_async_db).\n\n    Returns:\n        dict: The organisation details if found.\n\n    Raises:\n        HTTPException: If the organisation is not found or an error occurs.\n    \"\"\"\n    try:\n        repo = OrganisationRepository(session=db)\n        organisation = await repo.get_organisation_by_name(name)\n        if organisation:\n            return organisation\n        else:\n            raise HTTPException(status_code=404, detail=\"Organisation not found\")\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n</code></pre> <p>Delete an organisation by its ID.</p> <p>Parameters: - id (int): The ID of the organisation to be deleted. - db (AsyncSession): The asynchronous database session.</p> <p>Returns: - dict: A dictionary with a success message if the organisation is deleted successfully.</p> <p>Raises: - HTTPException: If an error occurs during the deletion process.</p> Source code in <code>app/main.py</code> <pre><code>@app.delete(\"/organisation/delete/{id}\")\nasync def delete_organisation(id: int, db: AsyncSession = Depends(get_async_db)):\n    \"\"\"\n    Delete an organisation by its ID.\n\n    Parameters:\n    - id (int): The ID of the organisation to be deleted.\n    - db (AsyncSession): The asynchronous database session.\n\n    Returns:\n    - dict: A dictionary with a success message if the organisation is deleted successfully.\n\n    Raises:\n    - HTTPException: If an error occurs during the deletion process.\n    \"\"\"\n    try:\n        repo = OrganisationRepository(session=db)\n        organisation = await repo.delete_organisation(id)\n        return {\"message\": \"Organisation deleted successfully\"}\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n</code></pre>"}]}